From a2fa1c72c3cf4ed64c16f7d1c0aaf5dc60c0f45c Mon Sep 17 00:00:00 2001
From: Paul Lesniewski <paul@squirrelmail.org>
Date: Thu, 28 Oct 2010 23:22:41 +0000
Subject: [PATCH 06/50] Fix LOGIN command so that it handles literal arguments
 correctly

git-svn-id: https://svn.code.sf.net/p/squirrelmail/code/trunk/imap_proxy@14069 7612ce4b-ef26-0410-bec9-ea0150e637f0
---
 ChangeLog     |  4 +++
 src/request.c | 94 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 2 files changed, 94 insertions(+), 4 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index b74c343..3d7c405 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,7 @@
+2010-10-28  Paul Lesniewski <paul@squirrelmail.org>
+	* Fixed LOGIN command so that it handles literal arguments
+          correctly.
+
 2010-08-19  Paul Lesniewski <paul@squirrelmail.org>
 	* Added several warnings that try to catch the case where someone
           tries to set the server_port to 993, which is usually a mistaken
diff --git a/src/request.c b/src/request.c
index 66f0e15..59ce9b2 100644
--- a/src/request.c
+++ b/src/request.c
@@ -1881,6 +1881,88 @@ extern void HandleRequest( int clientsd )
 	    S_UserName[ sizeof S_UserName - 1 ] = '\0';
 	    
 	    /*
+	     * Clients can send the username as a literal bytestream.  Check
+	     * for that here (the username we grabbed above will actually
+	     * be the literal token itself (the ONLY token on the line)
+	     * instead of the real username).
+	     */
+	    if ( Client.LiteralBytesRemaining
+	     && memtok( NULL, EndOfLine, &Lasts ) == NULL
+	     && S_UserName[ 0 ] == '{' && S_UserName[ strlen( S_UserName ) - 1 ] == '}' )
+	    {
+
+		if ( ( sizeof S_UserName - 1 ) < Client.LiteralBytesRemaining )
+		{
+		    syslog( LOG_ERR, "%s: username length would cause buffer overflow.", fn );
+		    /*
+		     * we have to at least eat the literal bytestream because
+		     * of the way our I/O routines work.
+		     */
+		    memset( &Client.ReadBuf, 0, sizeof Client.ReadBuf );
+		    Client.BytesInReadBuffer = 0;
+		    Client.ReadBytesProcessed = 0;
+		    Client.LiteralBytesRemaining = 0;
+		    Client.NonSyncLiteral = 0;
+		    Client.MoreData = 0;
+		    
+		    snprintf( SendBuf, BufLen, "%s NO LOGIN failed\r\n", S_Tag );
+		    if ( IMAP_Write( Client.conn, SendBuf, strlen(SendBuf) ) == -1 )
+		    {
+			IMAPCount->CurrentClientConnections--;
+			close( Client.conn->sd );
+			return;
+		    }
+		    continue;
+		}
+
+		CP = S_UserName;
+
+		if ( ! Client.NonSyncLiteral )
+		{
+		    sprintf( SendBuf, "+ go ahead\r\n" );
+		    if ( IMAP_Write( Client.conn, SendBuf, strlen(SendBuf) ) == -1 )
+		    {
+			IMAPCount->CurrentClientConnections--;
+			close( Client.conn->sd );
+			return;
+		    }
+		}
+
+		while ( Client.LiteralBytesRemaining )
+		{
+		    BytesRead = IMAP_Literal_Read( &Client );
+		    
+		    if ( BytesRead == -1 )
+		    {
+			syslog( LOG_NOTICE, "%s: Failed to read string literal from client on login.", fn );
+			snprintf( SendBuf, BufLen, "%s NO LOGIN failed\r\n", S_Tag );
+			if ( IMAP_Write( Client.conn, SendBuf, strlen(SendBuf) ) == -1 )
+			{
+			    IMAPCount->CurrentClientConnections--;
+			    close( Client.conn->sd );
+			    return;
+			}
+			continue;
+		    }
+		    
+		    memcpy ( (void *)CP, (const void *)Client.ReadBuf, BytesRead );
+		    CP += BytesRead;
+		}
+		*CP = '\0';
+
+		/*
+		 * Thankfully, IMAP_Literal_Read() leaves the rest of
+		 * the line in buffer, so we can read the rest now and
+		 * let the code below grab the password as usual, being
+		 * careful to reset our read/token pointers
+		 */
+		BytesRead = IMAP_Line_Read( &Client );
+		EndOfLine = Client.ReadBuf + BytesRead;
+		Lasts = Client.ReadBuf;
+
+	    }
+
+	    /*
 	     * Clients can send the password as a literal bytestream.  Check
 	     * for that here.
 	     */
@@ -1899,8 +1981,8 @@ extern void HandleRequest( int clientsd )
 		    Client.LiteralBytesRemaining = 0;
 		    Client.NonSyncLiteral = 0;
 		    Client.MoreData = 0;
-		    
-		    snprintf( SendBuf, BufLen, "%s NO LOGIN failed\r\n", Tag );
+
+		    snprintf( SendBuf, BufLen, "%s NO LOGIN failed\r\n", S_Tag );
 		    if ( IMAP_Write( Client.conn, SendBuf, strlen(SendBuf) ) == -1 )
 		    {
 			IMAPCount->CurrentClientConnections--;
@@ -1932,7 +2014,7 @@ extern void HandleRequest( int clientsd )
 		    if ( BytesRead == -1 )
 		    {
 			syslog( LOG_NOTICE, "%s: Failed to read string literal from client on login.", fn );
-			snprintf( SendBuf, BufLen, "%s NO LOGIN failed\r\n", Tag );
+			snprintf( SendBuf, BufLen, "%s NO LOGIN failed\r\n", S_Tag );
 			if ( IMAP_Write( Client.conn, SendBuf, strlen(SendBuf) ) == -1 )
 			{
 			    IMAPCount->CurrentClientConnections--;
@@ -1956,6 +2038,10 @@ extern void HandleRequest( int clientsd )
 		 * a real solution, but I hesitate to fiddle with 
 		 * IMAP_Literal_Read() right now since it works properly
 		 * otherwise.
+		 * Note: from the perspective of a naive user of this function
+		 * (elsewhere), the fact that it leaves the rest of the line
+		 * in the buffer is very helpful, so I'd say don't change that
+		 * behavior!
 		 */
 		rc = IMAP_Line_Read( &Client );
 	    }
@@ -1973,7 +2059,7 @@ extern void HandleRequest( int clientsd )
 		if ( Lasts >= CP )
 		{
 		    /* no password -- complain back to the client */
-		    snprintf( SendBuf, BufLen, "%s BAD Missing required argument to Login\r\n", Tag );
+		    snprintf( SendBuf, BufLen, "%s BAD Missing required argument to Login\r\n", S_Tag );
 		    if ( IMAP_Write( Client.conn, SendBuf, strlen(SendBuf) ) == -1 )
 		    {
 			IMAPCount->CurrentClientConnections--;
-- 
2.7.4

